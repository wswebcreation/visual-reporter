#!/usr/bin/env node
import { confirm, input, select } from "@inquirer/prompts";
import { copyFileSync, existsSync, mkdirSync, readdirSync } from "node:fs";
import { dirname, join, resolve } from "node:path";
import { exec, execSync } from "child_process";
import { fileURLToPath } from "node:url";
import { createRequire } from "node:module";

const require = createRequire(import.meta.url);
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const nextBinary = resolve(__dirname, "..", "node_modules/next/dist/bin/next");
const visualReporterProjectRoot = resolve(__dirname, "..");
const currentPath = process.cwd();
const CONFIG_HELPER_INTRO = `
=================================
ðŸ¤– WDIO Visual Reporter Wizard ðŸ§™
=================================

This utility will help you generate a visual report for your WebdriverIO Visual Tests. To make use of this utility, you need to have the 'output.json' file generated by the Visual Testing service. This file is only generated when you have the following in your configuration:

export const config = {
    // ...
    services: [
        [
            // Also installed as a dependency
            "visual-regression", 
            {
                createJsonReportFiles: true,
            },
        ],
    ],
    },
}

For more information, please refer to the WebdriverIO Visual Testing documentation: https://webdriver.io/docs/visual-testing.

The goal of this utility is to help you generate a visual report by helping you

1. find the 'output.json' file
2. provide the location where you want the visual report to be created
3. generate the visual report
4. view the visual report by starting a local server
`;

function listItems({
  folderPath,
  includeFiles,
}: {
  folderPath: string;
  includeFiles: boolean;
}) {
  const items = readdirSync(folderPath, { withFileTypes: true });
  const choices = items
    .filter((item) => {
      const trimmedName = item.name.trim();
      if (item.isDirectory() && !item.name.startsWith("node_modules")) {
        return true;
      }

      if (includeFiles) {
        return /\.json$/i.test(trimmedName);
      }

      return false;
    })
    .map((item) => {
      const isDirectory = item.isDirectory();
      const value = item.name + (isDirectory ? "/" : "");
      return {
        name: value,
        value,
      };
    });

  if (resolve(folderPath) !== resolve("/")) {
    choices.push({
      name: "\x1b[36mâ†© Go Back\x1b[0m",
      value: "..",
    });
  }

  if (!includeFiles) {
    choices.unshift({
      name: `This folder: ${folderPath}`,
      value: `selected-folder:${folderPath}`,
    });
  }

  return choices;
}

function clearPreviousPromptLines(message: string) {
  const terminalWidth = process.stdout.columns || 80;
  const lineCount = Math.ceil(message.length / terminalWidth);

  for (let i = 0; i < lineCount; i++) {
    process.stdout.write("\u001b[1A");
    process.stdout.write("\u001b[2K");
  }
}

async function chooseItems({
  currentPath,
  includeFiles = false,
}: {
  currentPath: string;
  includeFiles?: boolean;
}): Promise<string> {
  async function prompt(srcPath: string): Promise<string> {
    const promptMessage = `Please choose the Visual Testing output.json file (current folder: ${srcPath})`;
    const choices = listItems({ folderPath: srcPath, includeFiles });
    const answers = await select({
      message: promptMessage,
      choices: choices,
    });
    const newPath = join(srcPath, answers);

    if (
      (answers === ".." || answers.endsWith("/")) &&
      !answers.startsWith("selected-folder:")
    ) {
      clearPreviousPromptLines(promptMessage);
      return prompt(newPath);
    } else if (answers.startsWith("selected-folder:")) {
      return answers.split(":")[1];
    }

    return newPath;
  }

  return prompt(currentPath);
}

function runNpmScript(script: string) {
  return new Promise<void>((resolve, reject) => {
    exec(
      script,
      { cwd: visualReporterProjectRoot },
      (error, stdout, stderr) => {
        if (error) {
          console.error(`Error executing script: ${error.message}`);
          return reject(error);
        }

        if (stderr) {
          console.error(`Error output: ${stderr}`);
        }

        console.log(`Script output: ${stdout}`);
        resolve();
      }
    );
  });
}

function copyDirectory(src: string, dest: string) {
  if (!existsSync(dest)) {
    mkdirSync(dest, { recursive: true });
  }

  const entries = readdirSync(src, { withFileTypes: true });

  for (let entry of entries) {
    const srcPath = join(src, entry.name);
    const destPath = join(dest, entry.name);

    if (entry.isDirectory()) {
      copyDirectory(srcPath, destPath);
    } else {
      copyFileSync(srcPath, destPath);
    }
  }
}

async function main() {
  let filePath: string;
  let reportPath: string;
  console.log(CONFIG_HELPER_INTRO);

  const initialChoice = await select<{ method: "explore" | "type" }>({
    message: "How would you like to specify the file?",
    choices: [
      { name: 'Use a "file explorer"', value: { method: "explore" } },
      { name: "Type the file path manually", value: { method: "type" } },
    ],
  });

  if (initialChoice.method === "explore") {
    filePath = await chooseItems({ currentPath, includeFiles: true });
  } else {
    const pathInput = await input({
      message: "Please enter the file path:",
    });
    filePath = pathInput;
  }

  const reportFolderChoice = await select<{ method: "explore" | "type" }>({
    message: "Where do you want the Visual Report to be created?",
    choices: [
      { name: 'Use a "file explorer"', value: { method: "explore" } },
      { name: "Type the file path manually", value: { method: "type" } },
    ],
  });

  if (reportFolderChoice.method === "explore") {
    reportPath = await chooseItems({ currentPath });
  } else {
    const pathInput = await input({
      message: "Please enter the file path:",
    });
    reportPath = pathInput;
  }
  console.log("Building the report...");
  const reporterPath = join(reportPath, "report");
  await runNpmScript(
    `NEXT_PUBLIC_VISUAL_REPORT_OUTPUT_JSON_PATH=${filePath} npm run build`
  );

  if (!existsSync(reportPath)) {
    mkdirSync(reportPath, { recursive: true });
  }

  console.log(`Copying build output to ${reporterPath}...`);
  copyDirectory(
    join(visualReporterProjectRoot, ".next"),
    join(reporterPath, ".next")
  );

  console.log("Build output copied successfully.");

  const startServer = await confirm({
    message: "Would you like to start the server to show the report?",
  });

  if (startServer) {
    const serverPort = await input({
      message: "Please enter a custom server port:",
      default: "3000",
    });
    console.log("Starting the Next.js server...");
    execSync(`${nextBinary} start -p ${serverPort}`, {
      stdio: "inherit",
      cwd: reporterPath,
    });
  } else {
    process.exit(1);
  }
}

main().catch((error) => {
  if (error instanceof Error && error.message.includes("User force closed")) {
    console.log("\nProcess was closed by the user.\n");
  } else {
    console.error("An unexpected error occurred:", error);
  }
  process.exit(1);
});
